<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Learntool by SGH-HDU</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Learntool</h1>
      <h2 class="project-tagline">基础知识的学习讲义</h2>
      <a href="https://github.com/SGH-HDU/LearnTool" class="btn">View on GitHub</a>
      <a href="https://github.com/SGH-HDU/LearnTool/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/SGH-HDU/LearnTool/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="java-基本知识和面向对象" class="anchor" href="#java-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Java 基本知识和面向对象</h2>

<h3>
<a id="基本数据类型和运算符" class="anchor" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>基本数据类型和运算符</h3>

<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>int[]</li>
<li>long</li>
<li>boolean</li>
<li>char</li>
<li>char[]</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>!</li>
<li>%</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>+</li>
<li>//</li>
<li>++</li>
<li>- -</li>
</ul>

<h3>
<a id="判断筛选和循环" class="anchor" href="#%E5%88%A4%E6%96%AD%E7%AD%9B%E9%80%89%E5%92%8C%E5%BE%AA%E7%8E%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>判断，筛选和循环</h3>

<ul>
<li>if</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">int</span> say(<span class="pl-k">int</span> word){
  <span class="pl-k">int</span> a <span class="pl-k">=</span> word;
  <span class="pl-k">if</span>(a <span class="pl-k">==</span> <span class="pl-c1">1</span>){
      a <span class="pl-k">=</span> <span class="pl-c1">0</span>;
  }<span class="pl-k">else</span>{
      a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
  }
  <span class="pl-k">return</span> a;
}</pre></div>

<ul>
<li>switch</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">switch</span>(a){
  <span class="pl-k">case</span> <span class="pl-c1">0</span><span class="pl-k">:</span>
    a <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">break</span>;
  <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
    a <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-k">break</span>;
  <span class="pl-k">default</span><span class="pl-k">:</span>
    a <span class="pl-k">=</span> <span class="pl-c1">0</span>;
}</pre></div>

<ul>
<li>for</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">for</span>(<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>;i<span class="pl-k">&lt;</span><span class="pl-c1">10</span>;i<span class="pl-k">++</span>){
  <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>我循环啦！<span class="pl-pds">"</span></span>);
  <span class="pl-k">if</span>(i <span class="pl-k">==</span> <span class="pl-c1">3</span>){
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>跳过本次循环<span class="pl-pds">"</span></span>);
    <span class="pl-k">continue</span>;
  }
  <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>C要大写！<span class="pl-pds">"</span></span>);
}</pre></div>

<ul>
<li>while</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">void</span> speak(<span class="pl-k">int</span> key){
  <span class="pl-k">int</span> a <span class="pl-k">=</span> key;
  <span class="pl-k">while</span>(a<span class="pl-k">&gt;</span><span class="pl-c1">0</span>){
    a<span class="pl-k">--</span>;
    <span class="pl-k">if</span>(a <span class="pl-k">==</span> <span class="pl-c1">5</span>){
      <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>跳出循环<span class="pl-pds">"</span></span>);
      <span class="pl-k">break</span>;
    }<span class="pl-k">else</span> <span class="pl-k">if</span>(a <span class="pl-k">==</span> <span class="pl-c1">1</span>){
      <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>结束方法<span class="pl-pds">"</span></span>);
      <span class="pl-k">return</span>;
    }
  }
}</pre></div>

<ul>
<li>foreach</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">int</span>[] bbs <span class="pl-k">=</span> {<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>};
<span class="pl-k">for</span>(<span class="pl-k">int</span> bb <span class="pl-k">:</span> bbs){
  <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(bb);
}</pre></div>

<ul>
<li>do while</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">int</span> a <span class="pl-k">=</span> <span class="pl-c1">10</span>;
<span class="pl-k">do</span>{
  a<span class="pl-k">--</span>;
  <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>循环<span class="pl-pds">"</span></span>);
}<span class="pl-k">while</span>(a<span class="pl-k">&gt;</span><span class="pl-c1">3</span>);</pre></div>

<ul>
<li>5 &gt; 4 ? "y" : "n"   返回的是y</li>
</ul>

<h3>
<a id="面向对象" class="anchor" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>面向对象</h3>

<ul>
<li>思想

<ul>
<li>万事万物都是对象</li>
<li>每个对象都具有各自的状态特征（也可以称为属性）及行为特征（方法）</li>
<li>比如我们考虑一只狗，那么它的     状态是：名称，品种，颜色      行为：吠叫，摇摆，跑等</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Dog</span>{
   <span class="pl-k">private</span> <span class="pl-smi">String</span> breed;
   <span class="pl-k">private</span> <span class="pl-k">int</span> age;
   <span class="pl-k">private</span> <span class="pl-smi">String</span> color;

   <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">barking</span>(){
   }

   <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">hungry</span>(){
   }

   <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">sleeping</span>(){
   }
}</pre></div>

<h3>
<a id="构造方法" class="anchor" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>构造方法</h3>

<ul>
<li>介绍

<ul>
<li>构造方法是一种特殊的方法</li>
<li>构造方法的方法名必须与类名相同</li>
<li>构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型</li>
<li>构造方法的主要作用是<strong>完成对象的初始化工作</strong>，它能够把定义对象时的参数传给对象的域</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Puppy</span>{
   <span class="pl-k">private</span> <span class="pl-smi">String</span> name;

   <span class="pl-k">public</span> <span class="pl-en">Puppy</span>(){
   }

   <span class="pl-k">public</span> <span class="pl-en">Puppy</span>(<span class="pl-smi">String</span> <span class="pl-v">name</span>){
      <span class="pl-v">this</span><span class="pl-k">.</span>name <span class="pl-k">=</span> name;
   }
}</pre></div>

<h3>
<a id="继承" class="anchor" href="#%E7%BB%A7%E6%89%BF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>继承</h3>

<ul>
<li>介绍

<ul>
<li>继承一个类，子类会获得父类的所有成员变量和成员方法</li>
<li>一个类只能继承一个父类，但是可以被多个子类继承</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-k">int</span> age <span class="pl-k">=</span> <span class="pl-c1">40</span>;

    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getAge</span>(){
        <span class="pl-k">return</span> age;
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Dog</span> <span class="pl-k">extends</span> <span class="pl-e">Animal</span> {
    <span class="pl-k">public</span> <span class="pl-k">int</span> age <span class="pl-k">=</span> <span class="pl-c1">18</span>;
    <span class="pl-k">public</span> <span class="pl-smi">String</span> name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span>;

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getAge</span>() {
        <span class="pl-k">return</span> age;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-v">name</span>){
      <span class="pl-v">this</span><span class="pl-k">.</span>name <span class="pl-k">=</span> name;
    }   

    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>(){
        <span class="pl-k">return</span> name;
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Test</span>{
  <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span> <span class="pl-v">args</span>[]){
    <span class="pl-smi">Dog</span> d1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d1<span class="pl-k">.</span>getName());

    <span class="pl-c">//把父类实例赋给子类变量——相当于说动物是狗</span>
    <span class="pl-c">//把子类实例赋给父类变量——相当于说狗是动物</span>

    <span class="pl-smi">Dog</span> d2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Animal</span>(); <span class="pl-c">//变量其实只是给你的实例起个名字而已，这里类型转化后，还是Animal类型</span>
    d2<span class="pl-k">.</span>setName(<span class="pl-c1">30</span>); <span class="pl-c">//程序报错，因为d2的类型还是Animal，Animal没有setName的方法</span>

     <span class="pl-c">//父类对象由子类实例化</span>
    <span class="pl-smi">Animal</span> animal <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(animal<span class="pl-k">.</span>age);
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(animal<span class="pl-k">.</span>getAge());
    <span class="pl-c">//System.out.println(animal.getName()); 错误，Animal没有getName的方法</span>
   }
}</pre></div>

<div class="highlight highlight-source-java"><pre>结果：   <span class="pl-c">//animal变量访问变量是看 声明的类型，访问方法是看 实例的方法！</span>
    dog
    <span class="pl-c1">40</span>
    <span class="pl-c1">18</span></pre></div>

<ul>
<li>instanceof 运算符

<ul>
<li>左面的对象是右面的类创建的对象时,该运算符运算的结果是true,否则是false </li>
<li>instanceof左边操作元显式声明的类型与右边操作元必须是同种类或右边是左边父类的继承关系</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Test</span>{
  <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span> <span class="pl-v">args</span>[]){

      <span class="pl-smi">Animal</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Animal</span>();
      <span class="pl-smi">Dog</span> d <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Dog</span>();

      <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(a <span class="pl-k">instanceof</span> <span class="pl-smi">Animal</span>);
      <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d <span class="pl-k">instanceof</span> <span class="pl-smi">Animal</span>);
   }
}</pre></div>

<div class="highlight highlight-source-java"><pre>结果：
    <span class="pl-c1">true</span>
    <span class="pl-c1">true</span></pre></div>

<ul>
<li>重写

<ul>
<li>在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。</li>
</ul>
</li>
</ul>

<h3>
<a id="修饰词" class="anchor" href="#%E4%BF%AE%E9%A5%B0%E8%AF%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>修饰词</h3>

<ul>
<li>public

<ul>
<li>所有类都能直接访问</li>
</ul>
</li>
<li>private

<ul>
<li>只有自己的类才能访问</li>
</ul>
</li>
<li>protected

<ul>
<li>只有相同的包下的类才能访问</li>
</ul>
</li>
<li>final

<ul>
<li>final类不能被继承，没有子类，final类中的方法默认是final的</li>
<li>final方法不能被子类的方法覆盖，但可以被继承。</li>
<li>final成员变量或参数表示常量，只能被赋值一次，赋值后值不再改变。</li>
<li>final不能用于修饰构造方法。</li>
</ul>
</li>
<li>static

<ul>
<li> static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块</li>
<li> 被static修饰的成员变量和成员方法独立于该类的任何对象，即<strong>不需要实例化对象就能用类名.变量(方法)来使用</strong>
</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">final</span> <span class="pl-smi">String</span> <span class="pl-smi">StaticFinalVar</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>aaa<span class="pl-pds">"</span></span>; </pre></div>

<ul>
<li>this

<ul>
<li>this是对象，this.成员变量，this.函数（哪个对象调用的，this就代表该对象）</li>
<li>函数的参数与成员变量重名时，赋值语句使用 this.name = name; </li>
<li>this(name); 根据this所带的参数判断调用哪个构造函数。</li>
</ul>
</li>
<li>super

<ul>
<li>super();  调用父类构造函数 </li>
<li>super.成员函数； 调用父类成员函数或变量</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">test</span>{
  <span class="pl-k">private</span> <span class="pl-k">int</span> num;
  <span class="pl-k">private</span> <span class="pl-k">char</span> c;

  <span class="pl-c">//无参构造函数</span>
  <span class="pl-k">public</span> <span class="pl-en">test</span>(){

  }

  <span class="pl-c">//一个参数的构造函数</span>
  <span class="pl-k">public</span> <span class="pl-en">test</span>(<span class="pl-k">int</span> <span class="pl-v">num</span>){
    <span class="pl-v">this</span><span class="pl-k">.</span>num <span class="pl-k">=</span> num;
  }

  <span class="pl-c">//两个参数的构造函数</span>
  <span class="pl-k">public</span> <span class="pl-en">test</span>(<span class="pl-k">int</span> <span class="pl-v">num</span>,<span class="pl-k">char</span> <span class="pl-v">ch</span>){
    <span class="pl-c">//这里调用了第一个构造方法，并且必须放在新的构造方法的第一行</span>
    <span class="pl-v">this</span>(num);
    c <span class="pl-k">=</span> ch;
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getNum</span>(){
    <span class="pl-k">return</span> num;
  }

  <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setNum</span>(<span class="pl-k">int</span> <span class="pl-v">num</span>){
    <span class="pl-v">this</span><span class="pl-k">.</span>num <span class="pl-k">=</span> num;
  }

  <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-smi">String</span> []<span class="pl-v">args</span>) {
        test t <span class="pl-k">=</span> <span class="pl-k">new</span> test(<span class="pl-c1">8</span>);
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(t<span class="pl-k">.</span>getNum());
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">exam</span> <span class="pl-k">extends</span> test{
  <span class="pl-k">private</span> <span class="pl-k">int</span> grade;

  <span class="pl-k">public</span> <span class="pl-en">exam</span>(){
    <span class="pl-v">super</span>();
  }

  <span class="pl-k">public</span> <span class="pl-en">exam</span>(<span class="pl-k">int</span> <span class="pl-v">num</span>){
    <span class="pl-v">super</span>(num);
  }

  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">query</span>(<span class="pl-k">int</span> <span class="pl-v">gradeSheet</span>){
    <span class="pl-c">//super.num = gradeSheet;</span>
    <span class="pl-v">super</span><span class="pl-k">.</span>setNum(gradeSheet);
    <span class="pl-k">return</span> <span class="pl-v">super</span><span class="pl-k">.</span>getNum();
  }

  <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        exam e <span class="pl-k">=</span> <span class="pl-k">new</span> exam(<span class="pl-c1">3</span>);
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(e<span class="pl-k">.</span>getNum());

        <span class="pl-k">int</span> sheet <span class="pl-k">=</span> <span class="pl-c1">95</span>;
        e<span class="pl-k">.</span>query(sheet);
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(e<span class="pl-k">.</span>getNum());
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre>运行结果：
  <span class="pl-c1">3</span>
  <span class="pl-c1">95</span></pre></div>

<h3>
<a id="静态代码块" class="anchor" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>静态代码块</h3>

<ul>
<li>static

<ul>
<li>静态代码块里的使用的变量和方法也必须是static的</li>
<li>静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象就不会执行该类的非静态代码块</li>
<li>执行顺序：静态代码块------非静态代码块----构造函数</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StaticBlock</span> {
    <span class="pl-c">//静态代码块</span>
     <span class="pl-k">static</span> {
         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>静态块<span class="pl-pds">"</span></span>);
     }
    <span class="pl-c">//非静态代码块</span>
     {
         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>构造块，在类中定义<span class="pl-pds">"</span></span>);
     }
    <span class="pl-c">//构造函数</span>
     <span class="pl-k">public</span> <span class="pl-en">StaticBlock</span>() {
         <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>构造方法执行<span class="pl-pds">"</span></span>);
     }

     <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
         <span class="pl-k">new</span> <span class="pl-smi">StaticBlock</span>();
         <span class="pl-k">new</span> <span class="pl-smi">StaticBlock</span>();
     }

 }</pre></div>

<div class="highlight highlight-source-java"><pre>运行结果：
  静态块 
  构造块，在类中定义 
  构造方法执行 
  构造块，在类中定义 
  构造方法执行 </pre></div>

<ul>
<li>原理

<ul>
<li>实例化有两个步骤：1、类加载  2、new 对象</li>
<li>一个类在第一次被使用的时候会被类加载，然后在整个应用程序的生命周期当中不会再次被加载了，就加载这一次</li>
<li>因为static{}是在类加载时候被加载的，所以static{}也只会被加载一次</li>
</ul>
</li>
</ul>

<h3>
<a id="数据结构" class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据结构</h3>

<p><img src="http://www.maijinta.cn/user/files/collection.png" alt="collection"></p>

<ul>
<li>Collection (接口)</li>
<li>List (接口)

<ul>
<li>ArrayList (实现类)

<ul>
<li>非线程安全</li>
</ul>
</li>
<li>Vector (实现类)

<ul>
<li>线程安全</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">List&lt;<span class="pl-smi">Object</span>&gt;</span> objectList <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayList&lt;<span class="pl-smi">Object</span>&gt;</span>();
<span class="pl-smi">Object</span> object1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Object</span>();
<span class="pl-smi">Object</span> object2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Object</span>();
objectList<span class="pl-k">.</span>add(object1);
object2 <span class="pl-k">=</span> objectList<span class="pl-k">.</span>get(<span class="pl-c1">0</span>);
objectList<span class="pl-k">.</span>remove(<span class="pl-c1">0</span>);</pre></div>

<ul>
<li>Set (接口)

<ul>
<li>HashSet (实现类)

<ul>
<li>不能有重复的元素</li>
</ul>
</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Collection</span> books <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">HashSet</span>();
books<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span>01<span class="pl-pds">"</span></span>);
books<span class="pl-k">.</span>add(<span class="pl-s"><span class="pl-pds">"</span>02<span class="pl-pds">"</span></span>);</pre></div>

<ul>
<li>Iterator (接口)

<ul>
<li>只能用于Collection的遍历</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Iterator</span> it <span class="pl-k">=</span> books<span class="pl-k">.</span>iterator();
<span class="pl-k">while</span>(it<span class="pl-k">.</span>hasNext()){
  <span class="pl-smi">String</span> book <span class="pl-k">=</span> (<span class="pl-smi">String</span>)it<span class="pl-k">.</span>next();
  it<span class="pl-k">.</span>remove();
}</pre></div>

<p><img src="http://www.maijinta.cn/user/file/map.png" alt="map"></p>

<ul>
<li>Map (接口)

<ul>
<li>HashMap (实现类)</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">Map</span> map <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">HashMap</span>();
map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">"</span>boy<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>凯杰<span class="pl-pds">"</span></span>);
map<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">"</span>girl<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>青娜<span class="pl-pds">"</span></span>);
<span class="pl-k">if</span>(map<span class="pl-k">.</span>containKey(<span class="pl-s"><span class="pl-pds">"</span>boy<span class="pl-pds">"</span></span>)){
  <span class="pl-smi">String</span> name <span class="pl-k">=</span> map<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>boy<span class="pl-pds">"</span></span>);
  <span class="pl-k">for</span>(<span class="pl-smi">String</span> type <span class="pl-k">:</span> map<span class="pl-k">.</span>keySet()){
    name <span class="pl-k">=</span> map<span class="pl-k">.</span>remove(type);
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(name);
  }
}</pre></div>

<h3>
<a id="接口和抽象类" class="anchor" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>接口和抽象类</h3>

<ul>
<li>interface

<ul>
<li>接口是抽象方法的集合。一个类实现一个接口，从而继承接口的抽象方法</li>
<li>不能实例化一个接口</li>
<li>接口不包含任何构造函数</li>
<li>所有在接口中的方法都是抽象的</li>
<li>一个接口可以扩展多个接口</li>
<li>在接口中的每个方法也隐式抽象的，所以abstract关键字不需要</li>
<li>在接口中的方法是隐式公开的，即默认是public，不能写成private</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-c">//电脑类</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Computer</span> {  
    <span class="pl-c">//定义一个接口类型的成员变量</span>
    <span class="pl-k">private</span> <span class="pl-smi">ConnectToUsb</span> connectToUsb;  

    <span class="pl-c">//获得接口对象</span>
    <span class="pl-k">public</span> <span class="pl-smi">ConnectToUsb</span> <span class="pl-en">getConnectToUsb</span>() {  
        <span class="pl-k">return</span> connectToUsb;  
    }  
    <span class="pl-c">//赋值给接口  </span>
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setConnectToUsb</span>(<span class="pl-smi">ConnectToUsb</span> <span class="pl-v">connectToUsb</span>) {  
        <span class="pl-v">this</span><span class="pl-k">.</span>connectToUsb <span class="pl-k">=</span> connectToUsb;  
    }  

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">connect</span>() {  
        <span class="pl-c">//调用接口的方法</span>
        connectToUsb<span class="pl-k">.</span>connect();  
    }  
}  </pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">//USB接口</span>
<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">ConnectToUsb</span> {  
    <span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">void</span> <span class="pl-en">connect</span>();  
}  </pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">//MP3实现了USB接口的方法</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MpThree</span> <span class="pl-k">implements</span> <span class="pl-e">ConnectToUsb</span>{  
    <span class="pl-k">@Override</span>  
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">connect</span>() {  
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>MP3 To Connect!<span class="pl-pds">"</span></span>);  
    }  
}  </pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-c">//测试</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Test</span> {  
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {  
        <span class="pl-smi">Computer</span> c <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Computer</span>();  
        <span class="pl-smi">MpThree</span> m <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MpThree</span>();  
        c<span class="pl-k">.</span>setConnectToUsb(m);  
        c<span class="pl-k">.</span>connect();  
    }  
}  

结果：<span class="pl-c1">MP3</span> <span class="pl-smi">To</span> <span class="pl-smi">Connect</span><span class="pl-k">!</span></pre></div>

<ul>
<li>abstract

<ul>
<li>如果我们要定义的一个类的时候，没有足够的信息来描述一个具体的对象，还需要其他的具体类来支持</li>
<li>这个时候我们可以考虑使用抽象类。在类定义的前面增加abstract关键字，就表明一个类是抽象类。</li>
<li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li>
<li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-c">//形状父类</span>
<span class="pl-k">public</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Shapes</span> {
    <span class="pl-k">public</span> <span class="pl-k">int</span> x, y;
    <span class="pl-k">public</span> <span class="pl-k">int</span> width, height;
    <span class="pl-k">public</span> <span class="pl-en">Shapes</span>(<span class="pl-k">int</span> <span class="pl-v">x</span>, <span class="pl-k">int</span> <span class="pl-v">y</span>, <span class="pl-k">int</span> <span class="pl-v">width</span>, <span class="pl-k">int</span> <span class="pl-v">height</span>) {
       <span class="pl-v">this</span><span class="pl-k">.</span>x <span class="pl-k">=</span> x;
       <span class="pl-v">this</span><span class="pl-k">.</span>y <span class="pl-k">=</span> y;
       <span class="pl-v">this</span><span class="pl-k">.</span>width <span class="pl-k">=</span> width;
       <span class="pl-v">this</span><span class="pl-k">.</span>height <span class="pl-k">=</span> height;
    }
    <span class="pl-c">//计算面积</span>
    <span class="pl-k">abstract</span> <span class="pl-k">double</span> <span class="pl-en">getArea</span>();
    <span class="pl-c">//计算周长</span>
    <span class="pl-k">abstract</span> <span class="pl-k">double</span> <span class="pl-en">getPerimeter</span>();
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Circle</span> <span class="pl-k">extends</span> <span class="pl-e">Shapes</span> {
    <span class="pl-k">public</span> <span class="pl-k">double</span> r;
    <span class="pl-k">public</span> <span class="pl-k">double</span> <span class="pl-en">getArea</span>() {
       <span class="pl-k">return</span> (r <span class="pl-k">*</span> r <span class="pl-k">*</span> <span class="pl-smi">Math</span><span class="pl-c1"><span class="pl-k">.</span>PI</span>);
    }
    <span class="pl-k">public</span> <span class="pl-k">double</span> <span class="pl-en">getPerimeter</span>() {
       <span class="pl-k">return</span> (<span class="pl-c1">2</span> <span class="pl-k">*</span> <span class="pl-smi">Math</span><span class="pl-c1"><span class="pl-k">.</span>PI</span> <span class="pl-k">*</span> r);
    }
    <span class="pl-k">public</span> <span class="pl-en">Circle</span>(<span class="pl-k">int</span> <span class="pl-v">x</span>, <span class="pl-k">int</span> <span class="pl-v">y</span>, <span class="pl-k">int</span> <span class="pl-v">width</span>, <span class="pl-k">int</span> <span class="pl-v">heigh</span>) {
       <span class="pl-c">//调用父类构造函数</span>
       <span class="pl-v">super</span>(x, y, width, heigh);
       r <span class="pl-k">=</span> (<span class="pl-k">double</span>) width <span class="pl-k">/</span> <span class="pl-c1">2.0</span>;
    }
}</pre></div>

<ul>
<li>区别

<ul>
<li>接口作用

<ul>
<li>在业务逻辑设计的时候，可以只关注逻辑，不去写具体实现。等到接口写完后，你完全可以把具体实现交给其他人做，其他人按照你的业务逻辑就能完成。</li>
<li>当知道<strong>一件事肯定要多次被做</strong>或者<strong>将来功能扩展的时候会被做</strong>，但是每次做的方法都不一样的时候，你可以写个接口，相当于声明了这个方法，而具体实现可以等用的时候再写，这样可以使代码更加简洁明了。</li>
</ul>
</li>
<li>抽象类作用

<ul>
<li>多个类把共同的代码片段的抽取出来，做成一个基类。</li>
<li>相同行为，不同代码的成员方法，可以用抽象方法来代替，不去具体实现。</li>
<li>相同的代码，基类可以统一来具体实现了，节约了子类的代码</li>
</ul>
</li>
<li>两者区别

<ul>
<li>接口更加零散，他专注于概括不同的方法。抽象类更加像一个基类，为不同的子类做一个总的基础。</li>
<li>抽象类是对<strong>类</strong>的抽象，而接口是对<strong>行为</strong>的抽象</li>
</ul>
</li>
</ul>
</li>
</ul>

<h3>
<a id="多态" class="anchor" href="#%E5%A4%9A%E6%80%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>多态</h3>

<ul>
<li>多态的思想

<ul>
<li>继承，接口实现

<ul>
<li>狗是动物，猫是动物，鱼是动物</li>
<li>吃可以是吃饭，吃零食，吃大餐</li>
</ul>
</li>
<li>重载

<ul>
<li>一个方法可以有一个参数，两次参数或无数个参数，也可以是不同的返回类型，但方法名要一样</li>
</ul>
</li>
<li>运算符重载

<ul>
<li>运算符两边的东西不一样，作用也不一样</li>
</ul>
</li>
</ul>
</li>
<li>示例

<ul>
<li>例子太多，就不举啦<g-emoji alias="grinning" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f600.png" ios-version="6.0">😀</g-emoji>
</li>
</ul>
</li>
</ul>

<h3>
<a id="字符类" class="anchor" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>字符类</h3>

<ul>
<li>String和char[]</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-smi">String</span> str <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>GG<span class="pl-pds">"</span></span>;
<span class="pl-k">char</span>[] bm;
bm <span class="pl-k">=</span> str<span class="pl-k">.</span>toCharArray();
<span class="pl-c">//将 String 字符串 str 转换成数组</span>
str <span class="pl-k">=</span> <span class="pl-smi">String</span><span class="pl-k">.</span>valueOf(bm);
<span class="pl-c">//将 char 数组 bm 转换成字符串</span></pre></div>

<ul>
<li>String是一个引用类型，不是基本数据类型</li>
<li>StringBuffer

<ul>
<li>线程安全的</li>
</ul>
</li>
<li>StringBuilder

<ul>
<li>线程非安全的，会造成死锁</li>
</ul>
</li>
<li>
<p>StringBuffer与StringBuilder</p>

<ul>
<li>StringBuilder &gt;  StringBuffer</li>
<li>他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。</li>
<li>如果要操作少量的数据用 = String</li>
<li>如果单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li>
<li>如果多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li>
</ul>
</li>
<li><p>StringAPI</p></li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">char</span> charAt(<span class="pl-k">int</span> index) <span class="pl-c">//返回指定索引处的 char 值。</span>
<span class="pl-smi">String</span> concat(<span class="pl-smi">String</span> str) <span class="pl-c">//将指定字符串连接到此字符串的结尾。</span>
<span class="pl-k">boolean</span> contains(<span class="pl-smi">CharSequence</span> s) <span class="pl-c">//当且仅当此字符串包含指定的 char 值序列时，返回 true。</span>
<span class="pl-k">boolean</span> equals(<span class="pl-smi">Object</span> anObject) <span class="pl-c">//将此字符串与指定的对象比较。</span>
<span class="pl-k">int</span> indexOf(<span class="pl-smi">String</span> str) <span class="pl-c">//返回指定字符在此字符串中第一次出现处的索引(从0开始)。</span>
<span class="pl-k">int</span> lastindexOf(<span class="pl-smi">String</span> str) <span class="pl-c">//返回指定字符在此字符串中最后一次出现处的索引。</span>
<span class="pl-k">boolean</span> isEmpty() <span class="pl-c">//当且仅当 length() 为 0 时返回 true。</span>
<span class="pl-k">int</span> length() <span class="pl-c">//返回此字符串的长度。</span>
<span class="pl-smi">String</span> replace(<span class="pl-k">char</span> oldChar, <span class="pl-k">char</span> newChar) <span class="pl-c">// 返回一个新的字符串，替换此字符串中出现的所有oldChar</span>
<span class="pl-smi">String</span> trim() <span class="pl-c">//返回字符串的副本，忽略前导空白和尾部空白。</span></pre></div>

<h3>
<a id="枚举类" class="anchor" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>枚举类</h3>

<ul>
<li>enum</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">Color</span> {  
  <span class="pl-c1">RED</span>, <span class="pl-c1">GREEN</span>, <span class="pl-c1">BLANK</span>, <span class="pl-c1">YELLOW</span>  
} </pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">Signal</span> {
  <span class="pl-c1">GREEN</span>, <span class="pl-c1">YELLOW</span>, <span class="pl-c1">RED</span>
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TrafficLight</span> {
    <span class="pl-smi">Signal</span> color <span class="pl-k">=</span> <span class="pl-smi">Signal</span><span class="pl-c1"><span class="pl-k">.</span>RED</span>;

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">change</span>() {
        <span class="pl-k">switch</span> (color) {
        <span class="pl-k">case</span> <span class="pl-c1">RED</span><span class="pl-k">:</span>
            color <span class="pl-k">=</span> <span class="pl-smi">Signal</span><span class="pl-c1"><span class="pl-k">.</span>GREEN</span>;
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> <span class="pl-c1">YELLOW</span><span class="pl-k">:</span>
            color <span class="pl-k">=</span> <span class="pl-smi">Signal</span><span class="pl-c1"><span class="pl-k">.</span>RED</span>;
            <span class="pl-k">break</span>;
        <span class="pl-k">case</span> <span class="pl-c1">GREEN</span><span class="pl-k">:</span>
            color <span class="pl-k">=</span> <span class="pl-smi">Signal</span><span class="pl-c1"><span class="pl-k">.</span>YELLOW</span>;
            <span class="pl-k">break</span>;
        }
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">Color</span> {
    <span class="pl-c">//实例的对象</span>
    <span class="pl-c1">RED</span>(<span class="pl-s"><span class="pl-pds">"</span>红色<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>), <span class="pl-c1">GREEN</span>(<span class="pl-s"><span class="pl-pds">"</span>绿色<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>), <span class="pl-c1">BLANK</span>(<span class="pl-s"><span class="pl-pds">"</span>白色<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>), <span class="pl-c1">YELLO</span>(<span class="pl-s"><span class="pl-pds">"</span>黄色<span class="pl-pds">"</span></span>, <span class="pl-c1">4</span>);<span class="pl-c">//注意封号</span>
    <span class="pl-c">// 成员变量</span>
    <span class="pl-k">private</span> <span class="pl-smi">String</span> name;
    <span class="pl-k">private</span> <span class="pl-k">int</span> index;

    <span class="pl-c">// 构造方法</span>
    <span class="pl-k">private</span> <span class="pl-en">Color</span>(<span class="pl-smi">String</span> <span class="pl-v">name</span>, <span class="pl-k">int</span> <span class="pl-v">index</span>) {
        <span class="pl-v">this</span><span class="pl-k">.</span>name <span class="pl-k">=</span> name;
        <span class="pl-v">this</span><span class="pl-k">.</span>index <span class="pl-k">=</span> index;
    }

    <span class="pl-c">// 普通方法</span>
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>(<span class="pl-k">int</span> <span class="pl-v">index</span>) {
        <span class="pl-k">for</span> (<span class="pl-smi">Color</span> c <span class="pl-k">:</span> <span class="pl-smi">Color</span><span class="pl-k">.</span>values()) {
            <span class="pl-k">if</span> (c<span class="pl-k">.</span>getIndex() <span class="pl-k">==</span> index) {
                <span class="pl-k">return</span> c<span class="pl-k">.</span>name;
            }
        }
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

    <span class="pl-c">// get set 方法</span>
    <span class="pl-k">public</span> <span class="pl-smi">String</span> <span class="pl-en">getName</span>() {
        <span class="pl-k">return</span> name;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setName</span>(<span class="pl-smi">String</span> <span class="pl-v">name</span>) {
        <span class="pl-v">this</span><span class="pl-k">.</span>name <span class="pl-k">=</span> name;
    }

    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">getIndex</span>() {
        <span class="pl-k">return</span> index;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">setIndex</span>(<span class="pl-k">int</span> <span class="pl-v">index</span>) {
        <span class="pl-v">this</span><span class="pl-k">.</span>index <span class="pl-k">=</span> index;
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Main</span> {

    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-smi">Color</span> c <span class="pl-k">=</span> <span class="pl-smi">Color</span><span class="pl-c1"><span class="pl-k">.</span>RED</span>;
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(c<span class="pl-k">.</span>getName());
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre>结果：
    红色</pre></div>

<h3>
<a id="时间类" class="anchor" href="#%E6%97%B6%E9%97%B4%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>时间类</h3>

<ul>
<li>Date</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Main</span> {
    <span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> <span class="pl-en">main</span>(<span class="pl-k">String</span>[] <span class="pl-v">args</span>) {
        <span class="pl-smi">Date</span> d <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">Date</span>();
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d<span class="pl-k">.</span>getTime()); <span class="pl-c">//1970年到现在的毫秒数</span>
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d<span class="pl-k">.</span>getDate()); <span class="pl-c">//今天的日期</span>
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d<span class="pl-k">.</span>getDay()); <span class="pl-c">//今天的星期号</span>
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(d<span class="pl-k">.</span>getHours()); <span class="pl-c">//现在的小时数</span>
        ······
    }
}</pre></div>

<div class="highlight highlight-source-java"><pre>结果：
    <span class="pl-c1">1477131413252</span>
    <span class="pl-c1">22</span>
    <span class="pl-c1">6</span>
    <span class="pl-c1">18</span></pre></div>

<ul>
<li>SimpleDateFormat

<ul>
<li>一个格式化的时间工具类</li>
</ul>
</li>
<li>String转Date</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> main(<span class="pl-k">String</span>[] args) {
    <span class="pl-k">try</span> {
        <span class="pl-smi">String</span> dateString <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>2016-10-22 19:43:00<span class="pl-pds">"</span></span>;
        <span class="pl-smi">DateFormat</span> df <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">SimpleDateFormat</span>(<span class="pl-s"><span class="pl-pds">"</span>yyyy-MM-dd HH:mm:ss<span class="pl-pds">"</span></span>);
        <span class="pl-smi">Date</span> date <span class="pl-k">=</span> df<span class="pl-k">.</span>parse(dateString);
        <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(date);
    } <span class="pl-k">catch</span> (<span class="pl-smi">ParseException</span> e) {
        <span class="pl-c">// TODO Auto-generated catch block</span>
        e<span class="pl-k">.</span>printStackTrace();
    }
}
<span class="pl-c">//Sat Oct 22 19:43:00 CST 2016</span></pre></div>

<ul>
<li>Date转String</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-k">static</span> <span class="pl-k">void</span> main(<span class="pl-k">String</span>[] args) {
    <span class="pl-smi">String</span> time <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">SimpleDateFormat</span>(<span class="pl-s"><span class="pl-pds">"</span>yyyy-MM-dd HH:mm:ss<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>format(<span class="pl-k">new</span> <span class="pl-smi">Date</span>());
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(time);
}
<span class="pl-c">//2016-10-22 18:25:49</span></pre></div>

<h3>
<a id="加密类" class="anchor" href="#%E5%8A%A0%E5%AF%86%E7%B1%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>加密类</h3>

<ul>
<li>Hash 算法

<ul>
<li>它的算法的特征是不可逆性，并且才计算的时候所有的数据都参与了运算，其中任何一个数据变化了都会导致计算出来的Hash值完全不同，所以通常用来校验数据是否正确或用作身份验证。</li>
</ul>
</li>
<li>MD5

<ul>
<li>最常用的哈希算法</li>
</ul>
</li>
</ul>

<div class="highlight highlight-source-java"><pre><span class="pl-k">public</span> <span class="pl-smi">String</span> getMD5(<span class="pl-smi">String</span> s) {
        <span class="pl-k">char</span> hexDigits[]{<span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>1<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>2<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>3<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>4<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>5<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>6<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>7<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>8<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>9<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>B<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>C<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>D<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>E<span class="pl-pds">'</span></span>,<span class="pl-s"><span class="pl-pds">'</span>F<span class="pl-pds">'</span></span>};  
        <span class="pl-k">try</span> {
            <span class="pl-k">byte</span>[] btInput <span class="pl-k">=</span> s<span class="pl-k">.</span>getBytes(<span class="pl-s"><span class="pl-pds">"</span>utf-8<span class="pl-pds">"</span></span>);
            <span class="pl-smi">MessageDigest</span> mdInst <span class="pl-k">=</span> <span class="pl-smi">MessageDigest</span><span class="pl-k">.</span>getInstance(<span class="pl-s"><span class="pl-pds">"</span>MD5<span class="pl-pds">"</span></span>);
            mdInst<span class="pl-k">.</span>update(btInput);
            <span class="pl-k">byte</span>[] md <span class="pl-k">=</span> mdInst<span class="pl-k">.</span>digest();
            <span class="pl-k">int</span> j <span class="pl-k">=</span> md<span class="pl-k">.</span>length;
            <span class="pl-k">char</span> str[] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">char</span>[j <span class="pl-k">*</span> <span class="pl-c1">2</span>];
            <span class="pl-k">int</span> k <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> j; i<span class="pl-k">++</span>) {
                <span class="pl-k">byte</span> byte0 <span class="pl-k">=</span> md[i];
                str[k<span class="pl-k">++</span>] <span class="pl-k">=</span> hexDigits[byte0 <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">4</span> <span class="pl-k">&amp;</span> 0xf];
                str[k<span class="pl-k">++</span>] <span class="pl-k">=</span> hexDigits[byte0 <span class="pl-k">&amp;</span> 0xf];
            }
            <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">String</span>(str);
        } <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> e) {
            e<span class="pl-k">.</span>printStackTrace();
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
    }</pre></div>

<ul>
<li>SHA 

<ul>
<li>SHA加密原理又叫安全哈希加密技术，是当今世界最先进的加密算法</li>
</ul>
</li>
<li>MD5和SHA的区别

<ul>
<li>MD5比SHA快，SHA比MD5强度高，更安全</li>
</ul>
</li>
<li>salt 盐值

<ul>
<li>混淆原数据的值</li>
</ul>
</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/SGH-HDU/LearnTool">Learntool</a> is maintained by <a href="https://github.com/SGH-HDU">SGH-HDU</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
