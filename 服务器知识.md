## WEB后台知识



### Web服务器

**Web服务器作用**

专门处理客户端的HTTP请求，返回响应内容，使浏览器可以浏览网站的内容



### Apache服务器

Apache是一个用C语言编写的web服务器环境程序，启用它可以作为web服务器使用，不过只支持静态网页（HTML）



### Tomcat服务器

Tomcat是用Java语言编写的运行在Apache上的应用服务器，支持动态页面（ASP, PHP, JSP)

它是一个servlet容器，可以认为是apache的扩展，但是可以独立于apache运行。  

![](http://www.maijinta.cn/user/files/tomcat.png)



### Servlet

#### 简介

很久之前，我们的网页都是静态的，就是我们所看到的页面在编写好之后总是唯一的。后来有人便提出动态页面的概念，相应的就提出了Servlet。可以根据客户端的请求来判断返回什么页面。



#### 作用

负责处理客户请求，当客户请求来到时，Servlet容器获取请求，然后调用某个Servlet，并把Servlet的执行结果返回给客户。



#### Servlet 生命周期

- Servlet 通过调用 **init ()** 方法进行初始化
- Servlet 调用 **service()** 方法来处理客户端的请求
- Servlet 通过调用 **destroy()** 方法终止（结束）
- 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的




##### init() 方法

init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化。

当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。

init 方法的定义如下：

```java
public void init() throws ServletException {
  // 初始化代码...
}
```



##### service() 方法

service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。

每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。

下面是该方法的特征：

```java
public void service(ServletRequest request, ServletResponse response) 
	throws ServletException, IOException{
}
```

service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可。

doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。



##### doGet() 方法

GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。

```java
public void doGet(HttpServletRequest request,HttpServletResponse response)
    throws ServletException, IOException {
    // Servlet 代码
}
```



##### doPost() 方法

POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。

```java
public void doPost(HttpServletRequest request,HttpServletResponse response)
    throws ServletException, IOException {
    // Servlet 代码
}
```



##### destroy() 方法

destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。

在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：

```java
  public void destroy() {
    // 终止化代码...
  }
```



##### 具体流程

1. web client发送一个request请求。
2. Servlet容器接收我们这个请求，把web client的请求的信息封装成一个HttpServletRequest对象，以及HttpServletResponse对象。
3. Servlet容器把我们的HttpServletRequest对象，以及HttpServletResponse对象封装成一个参数传递给我们的httpservlet的service()方法。
4. 在service()里面我们通过读取我们的httpServletRequst里面的信息进行一些操作，然后写入一些信息进入我们的HttpServletResponse对象中。
5. 我们的servlet容器把我们的HttpServletResponse返回给我们的webclint。




##### 配置

**XML配置**

```xml
<servlet> 
	<servlet-name>Test</servlet-name> 
	<servlet-class>package.TestServlet</servlet-class> 
</servlet> 

<servlet-mapping> 
	<servlet-name>Test</servlet-name> 
	<url-pattern>/UrlTest</url-pattern> 
</servlet-mapping>
```



**注解配置**

Servlet 3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署描述

```java
@WebServlet(name="Servlet3Demo",urlPatterns="/Servlet3Demo")
```

> 注解WebServlet用来描述一个Servlet
>
> name描述Servlet的名字(可选) 
>
> urlPatterns定义访问的URL



### Jsp

#### 简介

JSP动态网页技术，是可以把Java语言嵌入到HTML页面上。

那时候Servlet是个大忙人，它既要处理显示效果，又要处理数据，又要处理页面跳转，耦合度高，不方便代码维护，为了解决这个问题，SUN公司联合其他公司制定了JSP动态网页技术标准。事实上jsp是一个特殊的Servlet实例，它跟其他Servlet一样被Servlet容器执行，在这之前它需要先被jsp容器转换成Servlet，这个过程是在服务器端产生的，在第一次编译之后该Servlet实例便常驻内存。



#### 编译指令

>  通知jsp引擎的消息

作用：设置jsp程序的属性以及由该jsp生成的serverlet里的属性



常用的编译指令有:

- page:该指令是针对当前页面的指令
- include :用于指定如何包含另一个页面
- taglib:用于定义和访问自定义标签




#### page指令

page指令主要用于定义当前jsp的全局指令，包括当前jsp所使用的脚本语言类型，需要导入Java包的列表等等,一般情况下page编译指令位于页面的最上方，一个页面可以有多个编译配置指令。



##### JSP 的page模版

最常用的是`import`，`contentType`，`pageEncoding`

```xml
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %>
```



##### 指令解释

- language：

  声明当前JSP页面使用的脚本语言的种类。目前该属性的值只能为java，默认值也为java，所以通常无须设置。


- import：

  用来导入包。默认导入的包有：java.lang.*, javax.servlet.*, javax.servlet.http.*, javax,.servlet.jsp.*.


- contentType：

  告知客户端，服务器对此次请求响应的正文格式(MIME类型)和编码字符集。默认为contentType="text/html;charset=UTF-8ISO-8859-1"。如设置为：contentType="text/html;charset=UTF-8"，就是告诉客户端，服务器响应的正文文件格式为text/html，这样客户端就会用默认的浏览器方式打开文件，而不用别的应用程序。charset=UTF-8告知客户端浏览器，服务器返回的文件编码格式为UTF-8，浏览器将按照UTF-8格式进行解码并且以UTF-8字符集进行页面显示。contentType的作用本质上相当于模拟了一个Http协议的消息头。contentType虽然写在JSP文件中，但是因为JSP文件其实并不能直接响应客户端请求，它必须编译成对应的Servlet以后才能响应请求。所以本质上这个contentType是针对Servlet的设置，即Servlet告诉客户端，我返回的文件(以流的形式,response.getWriter())的MIME类型为text/html,文件的编码字符集为UTF-8。


- pageEncoding：

  设定JSP源文件保存时所使用的编码。因为JSP文件要想响应客户端的请求，它就必须先被编译成一个Servlet，而Servlet是一个Java类，Java类在内存中是以Unicode进行编码的，如果JSP引擎(将JSP翻译成对应的Servlet)不知道JSP的编码格式，就无法进行解码，然后将其转换成内存中的Unicode编码。注意区分contentType的charset和pageEncoding，charset是响应时Servlet(JSP已经编译成了Servlet)告诉客户端浏览器”我“是以这种字符编码的，”你“也要以这种字符解码并显示，整个过程涉及服务器和客户端两方面，而pageEncoding是服务器端JSP文件告诉JSP引擎要以何种编码进行解码，即此时JSP还没被编译成Servlet，它是被编译成Servlet的前提准备工作，整个过程都发生在服务器端，与客户端无关。


- session：

  设定这个JSP页面是否支持session机制，默认为true，所以一般不需要设置，保持默认值即可。


- errorPage：

  指定错误处理页面的地址。如果本页面产生了异常或者错误，而该JSP页面没有对应的处理代码，此时就会自动调用该属性所指向的JSP页面。


- isErrorPage：

  和errorPage属性配合使用。设置本JSP页面是否为错误处理页面。


- buffer：

  指定输出缓冲区的大小。JSP的隐含对象out(JSP有九大隐含对象或者说内置对象)用于缓存JSP(其实是Servlet)对客户端浏览器的输出，默认值为8KB，可以设置为none，也可以设置为其他的值，单位为KB。


- autoFlush：

  当输出缓冲区即将溢出时，是否需要强制输出缓冲区的内容。设置为true时可以正常输出，设置为false时，则会在buffer溢出时产生一个异常。默认为true。


- isELIgnored：

  如果设定为真，那么JSP中的表达式被当成字符串处理。比如下面这个表达式${2000/20}在isELIgnored＝"true"时输出为${2000/20}，而isELIgnored＝"false"时输出为100.0。默认为false。




#### include指令