{
  "name": "Learntool",
  "tagline": "基础知识的学习讲义",
  "body": "## Java 基本知识和面向对象\r\n\r\n### 基本数据类型和运算符\r\n\r\n- byte\r\n- short\r\n- int\r\n- int[]\r\n- long\r\n- boolean\r\n- char\r\n- char[]\r\n- long\r\n- float\r\n- double\r\n- !\r\n- %\r\n- &&\r\n- ||\r\n- +\r\n- //\r\n- ++\r\n- \\- -\r\n\r\n\r\n\r\n\r\n### 判断，筛选和循环\r\n\r\n- if\r\n\r\n```java\r\npublic int say(int word){\r\n  int a = word;\r\n  if(a == 1){\r\n      a = 0;\r\n  }else{\r\n      a = 2;\r\n  }\r\n  return a;\r\n}\r\n```\r\n\r\n- switch\r\n\r\n\r\n```java\r\nswitch(a){\r\n  case 0:\r\n    a = 1;\r\n    break;\r\n  case 1:\r\n    a = 2;\r\n    break;\r\n  default:\r\n    a = 0;\r\n}\r\n```\r\n\r\n- for\r\n\r\n\r\n```java\r\nfor(int i = 0;i<10;i++){\r\n  System.out.println(\"我循环啦！\");\r\n  if(i == 3){\r\n    System.out.println(\"跳过本次循环\");\r\n    continue;\r\n  }\r\n  System.out.println(\"C要大写！\");\r\n}\r\n```\r\n\r\n- while\r\n\r\n\r\n```java\r\npublic void speak(int key){\r\n  int a = key;\r\n  while(a>0){\r\n    a--;\r\n    if(a == 5){\r\n      System.out.println(\"跳出循环\");\r\n      break;\r\n    }else if(a == 1){\r\n      System.out.println(\"结束方法\");\r\n      return;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n- foreach\r\n\r\n\r\n```java\r\nint[] bbs = {1,2,3,4,5};\r\nfor(int bb : bbs){\r\n  System.out.println(bb);\r\n}\r\n```\r\n\r\n- do while\r\n\r\n\r\n```java\r\nint a = 10;\r\ndo{\r\n  a--;\r\n  System.out.println(\"循环\");\r\n}while(a>3);\r\n```\r\n\r\n- 5 > 4 ? \"y\" : \"n\"   返回的是y\r\n\r\n\r\n\r\n\r\n### 面向对象\r\n\r\n- 思想\r\n  - 万事万物都是对象\r\n  - 每个对象都具有各自的状态特征（也可以称为属性）及行为特征（方法）\r\n  - 比如我们考虑一只狗，那么它的     状态是：名称，品种，颜色      行为：吠叫，摇摆，跑等\r\n\r\n\r\n```java\r\npublic class Dog{\r\n   private String breed;\r\n   private int age;\r\n   private String color;\r\n\r\n   public void barking(){\r\n   }\r\n   \r\n   public void hungry(){\r\n   }\r\n   \r\n   public void sleeping(){\r\n   }\r\n}\r\n```\r\n\r\n\r\n\r\n### 构造方法\r\n\r\n- 介绍\r\n  - 构造方法是一种特殊的方法\r\n  - 构造方法的方法名必须与类名相同\r\n  - 构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型\r\n  - 构造方法的主要作用是**完成对象的初始化工作**，它能够把定义对象时的参数传给对象的域\r\n\r\n\r\n```java\r\npublic class Puppy{\r\n   private String name;\r\n  \r\n   public Puppy(){\r\n   }\r\n\r\n   public Puppy(String name){\r\n      this.name = name;\r\n   }\r\n}\r\n```\r\n\r\n\r\n\r\n### 继承\r\n\r\n- 介绍\r\n  - 继承一个类，子类会获得父类的所有成员变量和成员方法\r\n  - 一个类只能继承一个父类，但是可以被多个子类继承\r\n\r\n```java\r\npublic class Animal {\r\n\tpublic int age = 40;\r\n\t\r\n\tpublic int getAge(){\r\n\t\treturn age;\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npublic class Dog extends Animal {\r\n\tpublic int age = 18;\r\n\tpublic String name = \"dog\";\r\n\r\n\t@Override\r\n\tpublic int getAge() {\r\n\t\treturn age;\r\n\t}\r\n\t\r\n  \tpublic void setName(String name){\r\n      this.name = name;\r\n  \t}\t\r\n  \r\n\tpublic String getName(){\r\n\t\treturn name;\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npublic class Test{\r\n  public static void main(String args[]){\r\n    Dog d1 = new Dog();\r\n    System.out.println(d1.getName());\r\n    \r\n    //把父类实例赋给子类变量——相当于说动物是狗\r\n    //把子类实例赋给父类变量——相当于说狗是动物\r\n    \r\n    Dog d2 = new Animal(); //变量其实只是给你的实例起个名字而已，这里类型转化后，还是Animal类型\r\n    d2.setName(30); //程序报错，因为d2的类型还是Animal，Animal没有setName的方法\r\n    \r\n     //父类对象由子类实例化\r\n    Animal animal = new Dog();\r\n    System.out.println(animal.age);\r\n    System.out.println(animal.getAge());\r\n    //System.out.println(animal.getName()); 错误，Animal没有getName的方法\r\n   }\r\n}\r\n```\r\n\r\n```java\r\n结果：   //animal变量访问变量是看 声明的类型，访问方法是看 实例的方法！\r\n\tdog\r\n  \t40\r\n\t18\r\n```\r\n\r\n- instanceof 运算符\r\n  - 左面的对象是右面的类创建的对象时,该运算符运算的结果是true,否则是false \r\n  - instanceof左边操作元显式声明的类型与右边操作元必须是同种类或右边是左边父类的继承关系\r\n\r\n```java\r\npublic class Test{\r\n  public static void main(String args[]){\r\n\r\n      Animal a = new Animal();\r\n      Dog d = new Dog();\r\n\r\n      System.out.println(a instanceof Animal);\r\n      System.out.println(d instanceof Animal);\r\n   }\r\n}\r\n```\r\n\r\n```java\r\n结果：\r\n\ttrue\r\n\ttrue\r\n```\r\n\r\n- 重写\r\n  - 在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。\r\n\r\n### 修饰词\r\n\r\n- public\r\n  - 所有类都能直接访问\r\n- private\r\n  - 只有自己的类才能访问\r\n- protected\r\n  - 只有相同的包下的类才能访问\r\n- final\r\n  - final类不能被继承，没有子类，final类中的方法默认是final的\r\n  - final方法不能被子类的方法覆盖，但可以被继承。\r\n  - final成员变量或参数表示常量，只能被赋值一次，赋值后值不再改变。\r\n  - final不能用于修饰构造方法。\r\n- static\r\n  -  static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块\r\n  -  被static修饰的成员变量和成员方法独立于该类的任何对象，即**不需要实例化对象就能用类名.变量(方法)来使用**\r\n\r\n```java\r\nprivate static final String StaticFinalVar = \"aaa\"; \r\n```\r\n\r\n- this\r\n  - this是对象，this.成员变量，this.函数（哪个对象调用的，this就代表该对象）\r\n  - 函数的参数与成员变量重名时，赋值语句使用 this.name = name; \r\n  - this(name); 根据this所带的参数判断调用哪个构造函数。\r\n- super\r\n  - super();  调用父类构造函数 \r\n  - super.成员函数； 调用父类成员函数或变量\r\n\r\n```java\r\npublic class test{\r\n  private int num;\r\n  private char c;\r\n  \r\n  //无参构造函数\r\n  public test(){\r\n    \r\n  }\r\n  \r\n  //一个参数的构造函数\r\n  public test(int num){\r\n    this.num = num;\r\n  }\r\n  \r\n  //两个参数的构造函数\r\n  public test(int num,char ch){\r\n    //这里调用了第一个构造方法，并且必须放在新的构造方法的第一行\r\n    this(num);\r\n    c = ch;\r\n  }\r\n  \r\n  public int getNum(){\r\n    return num;\r\n  }\r\n  \r\n  public void setNum(int num){\r\n    this.num = num;\r\n  }\r\n  \r\n  public static void main(String []args) {\r\n        test t = new test(8);\r\n\t\tSystem.out.println(t.getNum());\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class exam extends test{\r\n  private int grade;\r\n  \r\n  public exam(){\r\n    super();\r\n  }\r\n  \r\n  public exam(int num){\r\n    super(num);\r\n  }\r\n  \r\n  public int query(int gradeSheet){\r\n    //super.num = gradeSheet;\r\n    super.setNum(gradeSheet);\r\n\treturn super.getNum();\r\n  }\r\n  \r\n  public static void main(String[] args) {\r\n\t\texam e = new exam(3);\r\n\t\tSystem.out.println(e.getNum());\r\n\t\t\r\n\t\tint sheet = 95;\r\n\t\te.query(sheet);\r\n\t\tSystem.out.println(e.getNum());\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\n运行结果：\r\n  3\r\n  95\r\n```\r\n\r\n\r\n\r\n### 静态代码块\r\n\r\n- static\r\n  - 静态代码块里的使用的变量和方法也必须是static的\r\n  - 静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象就不会执行该类的非静态代码块\r\n  - 执行顺序：静态代码块------非静态代码块----构造函数\r\n\r\n\r\n```java\r\npublic class StaticBlock {\r\n\t//静态代码块\r\n     static {\r\n         System.out.println(\"静态块\");\r\n     }\r\n  \t//非静态代码块\r\n     {\r\n         System.out.println(\"构造块，在类中定义\");\r\n     }\r\n\t//构造函数\r\n     public StaticBlock() {\r\n         System.out.println(\"构造方法执行\");\r\n     }\r\n\r\n     public static void main(String[] args) {\r\n         new StaticBlock();\r\n         new StaticBlock();\r\n     }\r\n\r\n }\r\n```\r\n\r\n```java\r\n运行结果：\r\n  静态块 \r\n  构造块，在类中定义 \r\n  构造方法执行 \r\n  构造块，在类中定义 \r\n  构造方法执行 \r\n```\r\n\r\n- 原理\r\n  - 实例化有两个步骤：1、类加载  2、new 对象\r\n  - 一个类在第一次被使用的时候会被类加载，然后在整个应用程序的生命周期当中不会再次被加载了，就加载这一次\r\n  - 因为static{}是在类加载时候被加载的，所以static{}也只会被加载一次\r\n\r\n\r\n\r\n\r\n### 数据结构\r\n\r\n  ![collection](http://www.maijinta.cn/user/file/collection.png)\r\n\r\n- Collection (接口)\r\n- List (接口)\r\n  - ArrayList (实现类)\r\n    - 非线程安全\r\n  - Vector (实现类)\r\n    - 线程安全\r\n\r\n\r\n```java\r\nList<Object> objectList = new ArrayList<Object>();\r\nObject object1 = new Object();\r\nObject object2 = new Object();\r\nobjectList.add(object1);\r\nobject2 = objectList.get(0);\r\nobjectList.remove(0);\r\n```\r\n\r\n- Set (接口)\r\n  - HashSet (实现类)\r\n    - 不能有重复的元素\r\n\r\n\r\n```java\r\nCollection books = new HashSet();\r\nbooks.add(\"01\");\r\nbooks.add(\"02\");\r\n```\r\n\r\n- Iterator (接口)\r\n  - 只能用于Collection的遍历\r\n\r\n\r\n```java\r\nIterator it = books.iterator();\r\nwhile(it.hasNext()){\r\n  String book = (String)it.next();\r\n  it.remove();\r\n}\r\n```\r\n\r\n\r\n\r\n ![map](http://www.maijinta.cn/user/file/map.png)\r\n\r\n- Map (接口)\r\n  - HashMap (实现类)\r\n\r\n\r\n```java\r\nMap map = new HashMap();\r\nmap.put(\"boy\",\"凯杰\");\r\nmap.put(\"girl\",\"青娜\");\r\nif(map.containKey(\"boy\")){\r\n  String name = map.get(\"boy\");\r\n  for(String type : map.keySet()){\r\n    name = map.remove(type);\r\n    System.out.println(name);\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n### 接口和抽象类\r\n\r\n- interface\r\n  - 接口是抽象方法的集合。一个类实现一个接口，从而继承接口的抽象方法\r\n  - 不能实例化一个接口\r\n  - 接口不包含任何构造函数\r\n  - 所有在接口中的方法都是抽象的\r\n  - 一个接口可以扩展多个接口\r\n  - 在接口中的每个方法也隐式抽象的，所以abstract关键字不需要\r\n  - 在接口中的方法是隐式公开的，即默认是public，不能写成private\r\n\r\n\r\n```java\r\n//电脑类\r\npublic class Computer {  \r\n    //定义一个接口类型的成员变量\r\n    private ConnectToUsb connectToUsb;  \r\n  \r\n  \t//获得接口对象\r\n    public ConnectToUsb getConnectToUsb() {  \r\n        return connectToUsb;  \r\n    }  \r\n    //赋值给接口  \r\n    public void setConnectToUsb(ConnectToUsb connectToUsb) {  \r\n        this.connectToUsb = connectToUsb;  \r\n    }  \r\n    \r\n    public void connect() {  \r\n        //调用接口的方法\r\n        connectToUsb.connect();  \r\n    }  \r\n}  \r\n```\r\n\r\n```java\r\n//USB接口\r\npublic interface ConnectToUsb {  \r\n    public abstract void connect();  \r\n}  \r\n```\r\n\r\n```java\r\n//MP3实现了USB接口的方法\r\npublic class MpThree implements ConnectToUsb{  \r\n    @Override  \r\n    public void connect() {  \r\n        System.out.println(\"MP3 To Connect!\");  \r\n    }  \r\n}  \r\n```\r\n\r\n```java\r\n//测试\r\npublic class Test {  \r\n    public static void main(String[] args) {  \r\n        Computer c = new Computer();  \r\n        MpThree m = new MpThree();  \r\n        c.setConnectToUsb(m);  \r\n        c.connect();  \r\n    }  \r\n}  \r\n\r\n结果：MP3 To Connect!\r\n```\r\n\r\n- abstract\r\n  - 如果我们要定义的一个类的时候，没有足够的信息来描述一个具体的对象，还需要其他的具体类来支持\r\n  - 这个时候我们可以考虑使用抽象类。在类定义的前面增加abstract关键字，就表明一个类是抽象类。\r\n  - 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\r\n  - 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。\r\n\r\n\r\n```java\r\n//形状父类\r\npublic abstract class Shapes {\r\n    public int x, y;\r\n    public int width, height;\r\n    public Shapes(int x, int y, int width, int height) {\r\n       this.x = x;\r\n       this.y = y;\r\n       this.width = width;\r\n       this.height = height;\r\n    }\r\n    //计算面积\r\n    abstract double getArea();\r\n    //计算周长\r\n    abstract double getPerimeter();\r\n}\r\n```\r\n\r\n```java\r\npublic class Circle extends Shapes {\r\n    public double r;\r\n    public double getArea() {\r\n       return (r * r * Math.PI);\r\n    }\r\n    public double getPerimeter() {\r\n       return (2 * Math.PI * r);\r\n    }\r\n    public Circle(int x, int y, int width, int heigh) {\r\n       //调用父类构造函数\r\n       super(x, y, width, heigh);\r\n       r = (double) width / 2.0;\r\n    }\r\n}\r\n```\r\n\r\n- 区别\r\n  - 接口作用\r\n    - 在业务逻辑设计的时候，可以只关注逻辑，不去写具体实现。等到接口写完后，你完全可以把具体实现交给其他人做，其他人按照你的业务逻辑就能完成。\r\n    - 当知道**一件事肯定要多次被做**或者**将来功能扩展的时候会被做**，但是每次做的方法都不一样的时候，你可以写个接口，相当于声明了这个方法，而具体实现可以等用的时候再写，这样可以使代码更加简洁明了。\r\n  - 抽象类作用\r\n    - 多个类把共同的代码片段的抽取出来，做成一个基类。\r\n    - 相同行为，不同代码的成员方法，可以用抽象方法来代替，不去具体实现。\r\n    - 相同的代码，基类可以统一来具体实现了，节约了子类的代码\r\n  - 两者区别\r\n    - 接口更加零散，他专注于概括不同的方法。抽象类更加像一个基类，为不同的子类做一个总的基础。\r\n    - 抽象类是对**类**的抽象，而接口是对**行为**的抽象\r\n\r\n\r\n\r\n\r\n### 多态\r\n\r\n- 多态的思想\r\n  - 继承，接口实现\r\n    - 狗是动物，猫是动物，鱼是动物\r\n    - 吃可以是吃饭，吃零食，吃大餐\r\n  - 重载\r\n    - 一个方法可以有一个参数，两次参数或无数个参数，也可以是不同的返回类型，但方法名要一样\r\n  - 运算符重载\r\n    - 运算符两边的东西不一样，作用也不一样\r\n- 示例\r\n  - 例子太多，就不举啦😀\r\n\r\n\r\n\r\n\r\n### 字符类\r\n\r\n- String和char[]\r\n\r\n\r\n```java\r\nString str = \"GG\";\r\nchar[] bm;\r\nbm = str.toCharArray();\r\n//将 String 字符串 str 转换成数组\r\nstr = String.valueOf(bm);\r\n//将 char 数组 bm 转换成字符串\r\n```\r\n\r\n- String是一个引用类型，不是基本数据类型\r\n- StringBuffer\r\n  - 线程安全的\r\n- StringBuilder\r\n  - 线程非安全的，会造成死锁\r\n- StringBuffer与StringBuilder\r\n  - StringBuilder >  StringBuffer\r\n  - 他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度就快了。\r\n  - 如果要操作少量的数据用 = String\r\n  - 如果单线程操作字符串缓冲区 下操作大量数据 = StringBuilder\r\n  - 如果多线程操作字符串缓冲区 下操作大量数据 = StringBuffer\r\n\r\n\r\n- StringAPI\r\n\r\n\r\n```java\r\nchar charAt(int index) //返回指定索引处的 char 值。\r\nString concat(String str) //将指定字符串连接到此字符串的结尾。\r\nboolean\tcontains(CharSequence s) //当且仅当此字符串包含指定的 char 值序列时，返回 true。\r\nboolean\tequals(Object anObject) //将此字符串与指定的对象比较。\r\nint\tindexOf(String str) //返回指定字符在此字符串中第一次出现处的索引(从0开始)。\r\nint lastindexOf(String str) //返回指定字符在此字符串中最后一次出现处的索引。\r\nboolean\tisEmpty() //当且仅当 length() 为 0 时返回 true。\r\nint\tlength() //返回此字符串的长度。\r\nString replace(char oldChar, char newChar) // 返回一个新的字符串，替换此字符串中出现的所有oldChar\r\nString trim() //返回字符串的副本，忽略前导空白和尾部空白。\r\n```\r\n\r\n\r\n### 枚举类\r\n\r\n- enum\r\n\r\n\r\n```java\r\npublic enum Color {  \r\n  RED, GREEN, BLANK, YELLOW  \r\n} \r\n```\r\n\r\n```java\r\npublic enum Signal {\r\n  GREEN, YELLOW, RED\r\n}\r\n\r\npublic class TrafficLight {\r\n\tSignal color = Signal.RED;\r\n\r\n\tpublic void change() {\r\n\t\tswitch (color) {\r\n\t\tcase RED:\r\n\t\t\tcolor = Signal.GREEN;\r\n\t\t\tbreak;\r\n\t\tcase YELLOW:\r\n\t\t\tcolor = Signal.RED;\r\n\t\t\tbreak;\r\n\t\tcase GREEN:\r\n\t\t\tcolor = Signal.YELLOW;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npublic enum Color {\r\n  \t//实例的对象\r\n\tRED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);//注意封号\r\n\t// 成员变量\r\n\tprivate String name;\r\n\tprivate int index;\r\n\r\n\t// 构造方法\r\n\tprivate Color(String name, int index) {\r\n\t\tthis.name = name;\r\n\t\tthis.index = index;\r\n\t}\r\n\r\n\t// 普通方法\r\n\tpublic static String getName(int index) {\r\n\t\tfor (Color c : Color.values()) {\r\n\t\t\tif (c.getIndex() == index) {\r\n\t\t\t\treturn c.name;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// get set 方法\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\r\n\tpublic int getIndex() {\r\n\t\treturn index;\r\n\t}\r\n\r\n\tpublic void setIndex(int index) {\r\n\t\tthis.index = index;\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npublic class Main {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tColor c = Color.RED;\r\n\t\tSystem.out.println(c.getName());\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\n结果：\r\n\t红色\r\n```\r\n\r\n\r\n\r\n\r\n### 时间类\r\n\r\n- Date\r\n\r\n```java\r\npublic class Main {\r\n\tpublic static void main(String[] args) {\r\n\t\tDate d = new Date();\r\n\t\tSystem.out.println(d.getTime()); //1970年到现在的毫秒数\r\n\t\tSystem.out.println(d.getDate()); //今天的日期\r\n\t\tSystem.out.println(d.getDay()); //今天的星期号\r\n\t\tSystem.out.println(d.getHours()); //现在的小时数\r\n      \t······\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\n结果：\r\n\t1477131413252\r\n\t22\r\n\t6\r\n\t18\r\n```\r\n\r\n- SimpleDateFormat\r\n  - 一个格式化的时间工具类\r\n- String转Date\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\ttry {\r\n\t\tString dateString = \"2016-10-22 19:43:00\";\r\n\t\tDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\t\tDate date = df.parse(dateString);\r\n      \tSystem.out.println(date);\r\n\t} catch (ParseException e) {\r\n\t\t// TODO Auto-generated catch block\r\n\t\te.printStackTrace();\r\n\t}\r\n}\r\n//Sat Oct 22 19:43:00 CST 2016\r\n```\r\n\r\n- Date转String\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n\tString time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\r\n\tSystem.out.println(time);\r\n}\r\n//2016-10-22 18:25:49\r\n```\r\n\r\n\r\n\r\n### 加密类\r\n\r\n- Hash 算法\r\n  - 它的算法的特征是不可逆性，并且才计算的时候所有的数据都参与了运算，其中任何一个数据变化了都会导致计算出来的Hash值完全不同，所以通常用来校验数据是否正确或用作身份验证。\r\n- MD5\r\n  - 最常用的哈希算法\r\n\r\n```java\r\npublic String getMD5(String s) {\r\n        char hexDigits[]{'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};  \r\n  \t\ttry {\r\n            byte[] btInput = s.getBytes(\"utf-8\");\r\n            MessageDigest mdInst = MessageDigest.getInstance(\"MD5\");\r\n            mdInst.update(btInput);\r\n            byte[] md = mdInst.digest();\r\n            int j = md.length;\r\n            char str[] = new char[j * 2];\r\n            int k = 0;\r\n            for (int i = 0; i < j; i++) {\r\n                byte byte0 = md[i];\r\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\r\n                str[k++] = hexDigits[byte0 & 0xf];\r\n            }\r\n            return new String(str);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n```\r\n\r\n- SHA \r\n  - SHA加密原理又叫安全哈希加密技术，是当今世界最先进的加密算法\r\n- MD5和SHA的区别\r\n  - MD5比SHA快，SHA比MD5强度高，更安全\r\n- salt 盐值\r\n  - 混淆原数据的值",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}